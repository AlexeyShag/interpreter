# Interpreter

## Краткое описание 

Второе практической задание курса ФИВТ 'формальные языки и транялции' 2021 \
Первое задание находится тут: https://github.com/AlexeyShag/AlgoParsing (пожалуйста проверьте его кто-нибудь)

Реализован интерпретатор для языка программирования. Синтаксис языка похож на Pascal. Язык имеет динамическую типизацию.

Примеры кода:
```
a := 1 + 2;
b := 1 * (3 + 4);
c := "sfdfd";
d := true;
```

По вопросам писать сюда: @Alex_Shag (tg)

Для запуска интерпритатора прочтите документацию!

## Типы данных

В языке имеется три типа: целочисленный(int), логический(bool), сроковый(str). Для каждого типа определеный операции, у которых есть свои приоритеты:

Для целочисленого типа:
| Приоритет | #1 | #2 | #3|
| :---: | :---: | :---: | :---: |
| Операции | * / | + - | операторы сравнения|

Для строкового типа:
| Приоритет | #1 | #2 |
| :---: | :---: | :---: |
| Операции | конкатинация (+) | операторы сравнения|

Для логического типа:
| Приоритет | #1 | #2 |
| :---: | :---: | :---: |
| Операции | not and or xor | операторы сравнения|

Операторы сравнение определены для всех типов
| операторы сравнения | описание|
| :---: | :---: |
| < | меньше |
| <= | меньше или равно |
| > | больше |
| => | больше или равно |
| = | равно |
| <> | не равно |

## Константы

Константы целочисленного типа могут быть написаны последоательностью цифр( отрицательные константы не поддерживаются). Число должно влзить в int32_t.

Константы строкого типа могут быть написаны любой последовательностью печатуемых символов ASCII кроме '"'. Последовательность символов должна быть обернута в '"'.

Константы логического типа могут быть написаны как 'true' и 'false'

## Ввод Вывод

В языке есть 2 функции для ввода и вывод информации в поток.

read - функция ввода. 
```
read(variable1, variable2, ... );
```
Может принимать бесконечное число переменный, в которые будут записываться данные со стандартного потока ввода. Все данные что читаются с потока интерпритируются как строки, то есть переменная после ввода становится строковой.

Пример:
```
read(a, b, c);
```

write - функция ввода. 
```
write(expression1, expression2, ... );
```
Может принимать бесконечное число выражение. Выводит в стандартный поток вывода все типы.

Пример:
```
a := 1;
c := false;
b := "test";
write(a, " ", b, true);
```

## Преобразователи типов

При надобности можно явно скастовать перменную к определенному типу. Для этого используются следующие операторы:

| операторы преобразования | описание|
| :---: | :---: |
| cast_to_int | преобразовывает значение в целочисленное |
| cast_to_bool | преобразует значение в логическое |
| cast_to_str | преобразует значение в строку |

cast_to_int
| тип исходного значения | описание |
| :---: | :---: |
| int | преобразует без потерь |
| bool | если значение истино, то вернет 1 иначе 0 |
| str | каст произойдет верно, если строка является числом и не содержит лишние символы |

cast_to_bool
| тип исходного значения | описание |
| :---: | :---: |
| int | если 0 то вернет false иначе true |
| bool | преобразует без потерь |
| str | если "true" то вернет true, "false" - false иначе UB |

cast_to_str
| тип исходного значения | описание |
| :---: | :---: |
| int | преобразует без потерь |
| bool | true -> "true", false -> "false" |
| str | преобразует без потерь |

Что бы узнать какого типа сейчас перменная, можно использовать оператор get_type которая пернет одну из 3 строк: "int", "str", "bool".

Пример:

```
a := cast_to_bool(1); // a = true
c := cast_to_str(a); // c = "true"
b := cast_to_int(a); // b = 1
d := get_type(b); // d = "int"
```

## Комментарии

Да, они есть. Достаточно поставить "//" и строка станет комментарием

## Условный оператор

Условный оператор имеет следующую структуру:

```
if EXPRESSION then begin
  STATEMENTS
end;
```
EXPRESSION - выражение или переменная, которые обязаны возвращать bool ( автоматического каста нет)\
STATEMENTS - выполняется только в том случе если EXPRESSION = true. STATEMENTS не может быть пустым или поментариями!

Пример:
```
if (1 < 2) or (a > b) then begin
  write("test");
end;
```

Так же допускается наличие else блока.

```
if EXPRESSION then begin
  STATEMENTS1
end else begin
  STATEMENTS2
end;
```
EXPRESSION - выражение или переменная, которые обязаны возвращать bool ( автоматического каста нет) \
STATEMENTS1 - выполняется только в том случе если EXPRESSION = true. STATEMENTS1 не может быть пустым или поментариями! \
STATEMENTS2 - выполняется только в том случе если EXPRESSION = false. STATEMENTS2 не может быть пустым или поментариями!

Пример:
```
if (a > b) then begin
  write("test1");
end else begin
  write("test2");
end;
```

## Операторы циклов

Реализовано 2 цикл: for и while:

```
for VARIABLE to EXPRESSION2 do begin
  STATEMENTS1
end;

for VARIABLE:=EXPRESSION1 to EXPRESSION2 do begin
  STATEMENTS1
end;

for VARIABLE downto EXPRESSION2 do begin
  STATEMENTS1
end;

for VARIABLE:=EXPRESSION1 downto EXPRESSION2 do begin
  STATEMENTS1
end;
```
VARIABLE - счетцик цикла, обязяна быть инт \
EXPRESSION - выражение или перменная со значения которых начинается отсчет (может не быть) \
EXPRESSION2 - верхня границ счетчика, он остановится когда станет ему равным при этом все равно выполнеится. \
STATEMENTS1 - выполняется пока счетчик не станет равным EXPRESSION2. STATEMENTS1 не может быть пустым или поментариями!

Пример
```
for i:=0 to 10 do begin
  a := a + 1;
end;
write(a, " ", i); // 11 10
```

Так же поддерживается цикл с условием:

```
while EXPRESSION do begin
  STATEMENTS
end;
```

EXPRESSION - должно возвращать логическое значение (авто каста нет). \
STATEMENTS - выполняется пока EXPRESSION = true. STATEMENTS не может быть пустым или поментариями!

## Как запустить

Cначала прочитайте документацию!\

Пусть мы находимся с папке с проектом. Для начала проект нужно собрать.
```
mkdir build
cd build
CXX=clang++-10 CC=clang-10 cmake ..
make
```
После чего запустить можно следующим образом:
```
./interpreter <path_to_code>
```

## Коротко о том как это вообще все работает

Логически интерпритатор можно разделить на 3 части: разбор кода, построение дерева исполнения, исполнение кода.

Часть с разбором когда представляет из себя несколько автоматов и lexer, которые парсят слова и сопостявляют им теги.

Построением дерева занимаются комбинаторы, которые опираются на теги и строят зависимости для запуска.

Послдний этап это исполнение кода, тут ничего сложного, просто dfs по дереву запуск каждой вершинки.

## Литература

1. Dragon book
2. https://habr.com/ru/post/206320/

